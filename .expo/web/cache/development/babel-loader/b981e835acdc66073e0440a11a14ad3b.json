{"ast":null,"code":"'use strict';\n\nvar Buffer = require(\"./buffer\").Buffer;\n\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n\n  if (typeof nenc !== 'string' && !Buffer.isEncoding(enc)) throw new Error(\"Unknown encoding: \" + enc);\n  return nenc || enc;\n}\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var low;\n\n  for (;;) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n\n      case 'ucs2':\n      case 'utf16le':\n      case 'ucs-2':\n      case 'utf-16le':\n        return 'utf16le';\n\n      case 'binary':\n        return 'latin1';\n\n      case 'base64':\n      case 'ascii':\n      case 'latin1':\n      case 'hex':\n        return enc;\n\n      default:\n        if (low) return;\n        enc = ('' + enc).toLowerCase();\n        low = true;\n    }\n  }\n}\n\nexports.StringDecoder = StringDecoder;\n\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\nStringDecoder.prototype.text = utf8Text;\n\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return -1;\n}\n\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n\n  if (--j < i) return 0;\n  nb = utf8CheckByte(buf[j]);\n\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n\n  if (--j < i) return 0;\n  nb = utf8CheckByte(buf[j]);\n\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n\n    return nb;\n  }\n\n  return 0;\n}\n\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return \"\\uFFFD\".repeat(p);\n  }\n\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return \"\\uFFFD\".repeat(p + 1);\n    }\n\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return \"\\uFFFD\".repeat(p + 2);\n      }\n    }\n  }\n}\n\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + \"\\uFFFD\".repeat(this.lastTotal - this.lastNeed);\n  return r;\n}\n\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n\n    return r;\n  }\n\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","map":{"version":3,"sources":["/Users/adarsh/Documents/StocksUI/node_modules/react-native-stream/src/string_decoder.js"],"names":["Buffer","require","normalizeEncoding","enc","nenc","_normalizeEncoding","isEncoding","Error","low","toLowerCase","exports","StringDecoder","encoding","nb","text","utf16Text","end","utf16End","fillLast","utf8FillLast","base64Text","base64End","write","simpleWrite","simpleEnd","lastNeed","lastTotal","lastChar","allocUnsafe","prototype","buf","length","r","i","undefined","utf8End","utf8Text","copy","toString","utf8CheckByte","byte","utf8CheckIncomplete","self","j","utf8CheckExtraBytes","p","repeat","total","c","charCodeAt","slice","n"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Buffer = require('./buffer').Buffer;\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  const nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && !Buffer.isEncoding(enc))\n    throw new Error(`Unknown encoding: ${enc}`);\n  return nenc || enc;\n}\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var low;\n  for (;;) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'utf16le':\n      case 'ucs-2':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'latin1':\n      case 'hex':\n        return enc;\n      default:\n        if (low) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        low = true;\n    }\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function(buf) {\n  if (buf.length === 0)\n    return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined)\n      return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length)\n    return (r ? r + this.text(buf, i) : this.text(buf, i));\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function(buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F)\n    return 0;\n  else if (byte >> 5 === 0x06)\n    return 2;\n  else if (byte >> 4 === 0x0E)\n    return 3;\n  else if (byte >> 3 === 0x1E)\n    return 4;\n  return -1;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i)\n    return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0)\n      self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i)\n    return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0)\n      self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i)\n    return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2)\n        nb = 0;\n      else\n        self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// UTF-8 replacement characters ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd'.repeat(p);\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd'.repeat(p + 1);\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd'.repeat(p + 2);\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  const p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined)\n    return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  const total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed)\n    return buf.toString('utf8', i);\n  this.lastTotal = total;\n  const end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character for each buffered byte of a (partial)\n// character needs to be added to the output.\nfunction utf8End(buf) {\n  const r = (buf && buf.length ? this.write(buf) : '');\n  if (this.lastNeed)\n    return r + '\\ufffd'.repeat(this.lastTotal - this.lastNeed);\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    const r = buf.toString('utf16le', i);\n    if (r) {\n      const c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  const r = (buf && buf.length ? this.write(buf) : '');\n  if (this.lastNeed) {\n    const end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  const n = (buf.length - i) % 3;\n  if (n === 0)\n    return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\n\nfunction base64End(buf) {\n  const r = (buf && buf.length ? this.write(buf) : '');\n  if (this.lastNeed)\n    return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return (buf && buf.length ? this.write(buf) : '');\n}\n"]},"metadata":{},"sourceType":"script"}