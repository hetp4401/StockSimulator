{"ast":null,"code":"'use strict';\n\nvar OpenElementStack = require(\"../parser/open_element_stack\"),\n    Tokenizer = require(\"../tokenizer\"),\n    HTML = require(\"../common/html\");\n\nvar $ = HTML.TAG_NAMES;\n\nfunction setEndLocation(element, closingToken, treeAdapter) {\n  var loc = element.__location;\n  if (!loc) return;\n\n  if (!loc.startTag) {\n    loc.startTag = {\n      line: loc.line,\n      col: loc.col,\n      startOffset: loc.startOffset,\n      endOffset: loc.endOffset\n    };\n    if (loc.attrs) loc.startTag.attrs = loc.attrs;\n  }\n\n  if (closingToken.location) {\n    var ctLocation = closingToken.location,\n        tn = treeAdapter.getTagName(element),\n        isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n\n    if (isClosingEndTag) {\n      loc.endTag = {\n        line: ctLocation.line,\n        col: ctLocation.col,\n        startOffset: ctLocation.startOffset,\n        endOffset: ctLocation.endOffset\n      };\n    }\n\n    if (isClosingEndTag) loc.endOffset = ctLocation.endOffset;else loc.endOffset = ctLocation.startOffset;\n  }\n}\n\nexports.assign = function (parser) {\n  var parserProto = Object.getPrototypeOf(parser),\n      treeAdapter = parser.treeAdapter,\n      attachableElementLocation = null,\n      lastFosterParentingLocation = null,\n      currentToken = null;\n\n  parser._bootstrap = function (document, fragmentContext) {\n    parserProto._bootstrap.call(this, document, fragmentContext);\n\n    attachableElementLocation = null;\n    lastFosterParentingLocation = null;\n    currentToken = null;\n\n    parser.openElements.pop = function () {\n      setEndLocation(this.current, currentToken, treeAdapter);\n      OpenElementStack.prototype.pop.call(this);\n    };\n\n    parser.openElements.popAllUpToHtmlElement = function () {\n      for (var i = this.stackTop; i > 0; i--) {\n        setEndLocation(this.items[i], currentToken, treeAdapter);\n      }\n\n      OpenElementStack.prototype.popAllUpToHtmlElement.call(this);\n    };\n\n    parser.openElements.remove = function (element) {\n      setEndLocation(element, currentToken, treeAdapter);\n      OpenElementStack.prototype.remove.call(this, element);\n    };\n  };\n\n  parser._processTokenInForeignContent = function (token) {\n    currentToken = token;\n\n    parserProto._processTokenInForeignContent.call(this, token);\n  };\n\n  parser._processToken = function (token) {\n    currentToken = token;\n\n    parserProto._processToken.call(this, token);\n\n    if (token.type === Tokenizer.END_TAG_TOKEN && (token.tagName === $.HTML || token.tagName === $.BODY && this.openElements.hasInScope($.BODY))) {\n      for (var i = this.openElements.stackTop; i >= 0; i--) {\n        var element = this.openElements.items[i];\n\n        if (this.treeAdapter.getTagName(element) === token.tagName) {\n          setEndLocation(element, token, treeAdapter);\n          break;\n        }\n      }\n    }\n  };\n\n  parser._setDocumentType = function (token) {\n    parserProto._setDocumentType.call(this, token);\n\n    var documentChildren = this.treeAdapter.getChildNodes(this.document),\n        cnLength = documentChildren.length;\n\n    for (var i = 0; i < cnLength; i++) {\n      var node = documentChildren[i];\n\n      if (this.treeAdapter.isDocumentTypeNode(node)) {\n        node.__location = token.location;\n        break;\n      }\n    }\n  };\n\n  parser._attachElementToTree = function (element) {\n    element.__location = attachableElementLocation || null;\n    attachableElementLocation = null;\n\n    parserProto._attachElementToTree.call(this, element);\n  };\n\n  parser._appendElement = function (token, namespaceURI) {\n    attachableElementLocation = token.location;\n\n    parserProto._appendElement.call(this, token, namespaceURI);\n  };\n\n  parser._insertElement = function (token, namespaceURI) {\n    attachableElementLocation = token.location;\n\n    parserProto._insertElement.call(this, token, namespaceURI);\n  };\n\n  parser._insertTemplate = function (token) {\n    attachableElementLocation = token.location;\n\n    parserProto._insertTemplate.call(this, token);\n\n    var tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n    tmplContent.__location = null;\n  };\n\n  parser._insertFakeRootElement = function () {\n    parserProto._insertFakeRootElement.call(this);\n\n    this.openElements.current.__location = null;\n  };\n\n  parser._appendCommentNode = function (token, parent) {\n    parserProto._appendCommentNode.call(this, token, parent);\n\n    var children = this.treeAdapter.getChildNodes(parent),\n        commentNode = children[children.length - 1];\n    commentNode.__location = token.location;\n  };\n\n  parser._findFosterParentingLocation = function () {\n    lastFosterParentingLocation = parserProto._findFosterParentingLocation.call(this);\n    return lastFosterParentingLocation;\n  };\n\n  parser._insertCharacters = function (token) {\n    parserProto._insertCharacters.call(this, token);\n\n    var hasFosterParent = this._shouldFosterParentOnInsertion(),\n        parent = hasFosterParent && lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current,\n        siblings = this.treeAdapter.getChildNodes(parent),\n        textNodeIdx = hasFosterParent && lastFosterParentingLocation.beforeElement ? siblings.indexOf(lastFosterParentingLocation.beforeElement) - 1 : siblings.length - 1,\n        textNode = siblings[textNodeIdx];\n\n    if (textNode.__location) textNode.__location.endOffset = token.location.endOffset;else textNode.__location = token.location;\n  };\n};","map":{"version":3,"sources":["/Users/adarsh/Documents/StocksUI/node_modules/react-native-parse-html/lib/location_info/parser_mixin.js"],"names":["OpenElementStack","require","Tokenizer","HTML","$","TAG_NAMES","setEndLocation","element","closingToken","treeAdapter","loc","__location","startTag","line","col","startOffset","endOffset","attrs","location","ctLocation","tn","getTagName","isClosingEndTag","type","END_TAG_TOKEN","tagName","endTag","exports","assign","parser","parserProto","Object","getPrototypeOf","attachableElementLocation","lastFosterParentingLocation","currentToken","_bootstrap","document","fragmentContext","call","openElements","pop","current","prototype","popAllUpToHtmlElement","i","stackTop","items","remove","_processTokenInForeignContent","token","_processToken","BODY","hasInScope","_setDocumentType","documentChildren","getChildNodes","cnLength","length","node","isDocumentTypeNode","_attachElementToTree","_appendElement","namespaceURI","_insertElement","_insertTemplate","tmplContent","getTemplateContent","_insertFakeRootElement","_appendCommentNode","parent","children","commentNode","_findFosterParentingLocation","_insertCharacters","hasFosterParent","_shouldFosterParentOnInsertion","currentTmplContent","siblings","textNodeIdx","beforeElement","indexOf","textNode"],"mappings":"AAAA;;AAEA,IAAIA,gBAAgB,GAAGC,OAAO,gCAA9B;AAAA,IACIC,SAAS,GAAGD,OAAO,gBADvB;AAAA,IAEIE,IAAI,GAAGF,OAAO,kBAFlB;;AAMA,IAAIG,CAAC,GAAGD,IAAI,CAACE,SAAb;;AAGA,SAASC,cAAT,CAAwBC,OAAxB,EAAiCC,YAAjC,EAA+CC,WAA/C,EAA4D;AACxD,MAAIC,GAAG,GAAGH,OAAO,CAACI,UAAlB;AAEA,MAAI,CAACD,GAAL,EACI;;AASJ,MAAI,CAACA,GAAG,CAACE,QAAT,EAAmB;AACfF,IAAAA,GAAG,CAACE,QAAJ,GAAe;AACXC,MAAAA,IAAI,EAAEH,GAAG,CAACG,IADC;AAEXC,MAAAA,GAAG,EAAEJ,GAAG,CAACI,GAFE;AAGXC,MAAAA,WAAW,EAAEL,GAAG,CAACK,WAHN;AAIXC,MAAAA,SAAS,EAAEN,GAAG,CAACM;AAJJ,KAAf;AAMA,QAAIN,GAAG,CAACO,KAAR,EACIP,GAAG,CAACE,QAAJ,CAAaK,KAAb,GAAqBP,GAAG,CAACO,KAAzB;AACP;;AAED,MAAIT,YAAY,CAACU,QAAjB,EAA2B;AACvB,QAAIC,UAAU,GAAGX,YAAY,CAACU,QAA9B;AAAA,QACIE,EAAE,GAAGX,WAAW,CAACY,UAAZ,CAAuBd,OAAvB,CADT;AAAA,QAIIe,eAAe,GAAGd,YAAY,CAACe,IAAb,KAAsBrB,SAAS,CAACsB,aAAhC,IACAJ,EAAE,KAAKZ,YAAY,CAACiB,OAL1C;;AAOA,QAAIH,eAAJ,EAAqB;AACjBZ,MAAAA,GAAG,CAACgB,MAAJ,GAAa;AACTb,QAAAA,IAAI,EAAEM,UAAU,CAACN,IADR;AAETC,QAAAA,GAAG,EAAEK,UAAU,CAACL,GAFP;AAGTC,QAAAA,WAAW,EAAEI,UAAU,CAACJ,WAHf;AAITC,QAAAA,SAAS,EAAEG,UAAU,CAACH;AAJb,OAAb;AAMH;;AAED,QAAIM,eAAJ,EACIZ,GAAG,CAACM,SAAJ,GAAgBG,UAAU,CAACH,SAA3B,CADJ,KAGIN,GAAG,CAACM,SAAJ,GAAgBG,UAAU,CAACJ,WAA3B;AACP;AACJ;;AAGDY,OAAO,CAACC,MAAR,GAAiB,UAAUC,MAAV,EAAkB;AAE/B,MAAIC,WAAW,GAAGC,MAAM,CAACC,cAAP,CAAsBH,MAAtB,CAAlB;AAAA,MACIpB,WAAW,GAAGoB,MAAM,CAACpB,WADzB;AAAA,MAEIwB,yBAAyB,GAAG,IAFhC;AAAA,MAGIC,2BAA2B,GAAG,IAHlC;AAAA,MAIIC,YAAY,GAAG,IAJnB;;AAQAN,EAAAA,MAAM,CAACO,UAAP,GAAoB,UAAUC,QAAV,EAAoBC,eAApB,EAAqC;AACrDR,IAAAA,WAAW,CAACM,UAAZ,CAAuBG,IAAvB,CAA4B,IAA5B,EAAkCF,QAAlC,EAA4CC,eAA5C;;AAEAL,IAAAA,yBAAyB,GAAG,IAA5B;AACAC,IAAAA,2BAA2B,GAAG,IAA9B;AACAC,IAAAA,YAAY,GAAG,IAAf;;AAGAN,IAAAA,MAAM,CAACW,YAAP,CAAoBC,GAApB,GAA0B,YAAY;AAClCnC,MAAAA,cAAc,CAAC,KAAKoC,OAAN,EAAeP,YAAf,EAA6B1B,WAA7B,CAAd;AACAT,MAAAA,gBAAgB,CAAC2C,SAAjB,CAA2BF,GAA3B,CAA+BF,IAA/B,CAAoC,IAApC;AACH,KAHD;;AAKAV,IAAAA,MAAM,CAACW,YAAP,CAAoBI,qBAApB,GAA4C,YAAY;AACpD,WAAK,IAAIC,CAAC,GAAG,KAAKC,QAAlB,EAA4BD,CAAC,GAAG,CAAhC,EAAmCA,CAAC,EAApC;AACIvC,QAAAA,cAAc,CAAC,KAAKyC,KAAL,CAAWF,CAAX,CAAD,EAAgBV,YAAhB,EAA8B1B,WAA9B,CAAd;AADJ;;AAGAT,MAAAA,gBAAgB,CAAC2C,SAAjB,CAA2BC,qBAA3B,CAAiDL,IAAjD,CAAsD,IAAtD;AACH,KALD;;AAOAV,IAAAA,MAAM,CAACW,YAAP,CAAoBQ,MAApB,GAA6B,UAAUzC,OAAV,EAAmB;AAC5CD,MAAAA,cAAc,CAACC,OAAD,EAAU4B,YAAV,EAAwB1B,WAAxB,CAAd;AACAT,MAAAA,gBAAgB,CAAC2C,SAAjB,CAA2BK,MAA3B,CAAkCT,IAAlC,CAAuC,IAAvC,EAA6ChC,OAA7C;AACH,KAHD;AAIH,GAxBD;;AA4BAsB,EAAAA,MAAM,CAACoB,6BAAP,GAAuC,UAAUC,KAAV,EAAiB;AACpDf,IAAAA,YAAY,GAAGe,KAAf;;AACApB,IAAAA,WAAW,CAACmB,6BAAZ,CAA0CV,IAA1C,CAA+C,IAA/C,EAAqDW,KAArD;AACH,GAHD;;AAKArB,EAAAA,MAAM,CAACsB,aAAP,GAAuB,UAAUD,KAAV,EAAiB;AACpCf,IAAAA,YAAY,GAAGe,KAAf;;AACApB,IAAAA,WAAW,CAACqB,aAAZ,CAA0BZ,IAA1B,CAA+B,IAA/B,EAAqCW,KAArC;;AAIA,QAAIA,KAAK,CAAC3B,IAAN,KAAerB,SAAS,CAACsB,aAAzB,KACC0B,KAAK,CAACzB,OAAN,KAAkBrB,CAAC,CAACD,IAApB,IACA+C,KAAK,CAACzB,OAAN,KAAkBrB,CAAC,CAACgD,IAApB,IAA4B,KAAKZ,YAAL,CAAkBa,UAAlB,CAA6BjD,CAAC,CAACgD,IAA/B,CAF7B,CAAJ,EAEwE;AACpE,WAAK,IAAIP,CAAC,GAAG,KAAKL,YAAL,CAAkBM,QAA/B,EAAyCD,CAAC,IAAI,CAA9C,EAAiDA,CAAC,EAAlD,EAAsD;AAClD,YAAItC,OAAO,GAAG,KAAKiC,YAAL,CAAkBO,KAAlB,CAAwBF,CAAxB,CAAd;;AAEA,YAAI,KAAKpC,WAAL,CAAiBY,UAAjB,CAA4Bd,OAA5B,MAAyC2C,KAAK,CAACzB,OAAnD,EAA4D;AACxDnB,UAAAA,cAAc,CAACC,OAAD,EAAU2C,KAAV,EAAiBzC,WAAjB,CAAd;AACA;AACH;AACJ;AACJ;AACJ,GAlBD;;AAsBAoB,EAAAA,MAAM,CAACyB,gBAAP,GAA0B,UAAUJ,KAAV,EAAiB;AACvCpB,IAAAA,WAAW,CAACwB,gBAAZ,CAA6Bf,IAA7B,CAAkC,IAAlC,EAAwCW,KAAxC;;AAEA,QAAIK,gBAAgB,GAAG,KAAK9C,WAAL,CAAiB+C,aAAjB,CAA+B,KAAKnB,QAApC,CAAvB;AAAA,QACIoB,QAAQ,GAAGF,gBAAgB,CAACG,MADhC;;AAGA,SAAK,IAAIb,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGY,QAApB,EAA8BZ,CAAC,EAA/B,EAAmC;AAC/B,UAAIc,IAAI,GAAGJ,gBAAgB,CAACV,CAAD,CAA3B;;AAEA,UAAI,KAAKpC,WAAL,CAAiBmD,kBAAjB,CAAoCD,IAApC,CAAJ,EAA+C;AAC3CA,QAAAA,IAAI,CAAChD,UAAL,GAAkBuC,KAAK,CAAChC,QAAxB;AACA;AACH;AACJ;AACJ,GAdD;;AAkBAW,EAAAA,MAAM,CAACgC,oBAAP,GAA8B,UAAUtD,OAAV,EAAmB;AAG7CA,IAAAA,OAAO,CAACI,UAAR,GAAqBsB,yBAAyB,IAAI,IAAlD;AACAA,IAAAA,yBAAyB,GAAG,IAA5B;;AACAH,IAAAA,WAAW,CAAC+B,oBAAZ,CAAiCtB,IAAjC,CAAsC,IAAtC,EAA4ChC,OAA5C;AACH,GAND;;AAQAsB,EAAAA,MAAM,CAACiC,cAAP,GAAwB,UAAUZ,KAAV,EAAiBa,YAAjB,EAA+B;AACnD9B,IAAAA,yBAAyB,GAAGiB,KAAK,CAAChC,QAAlC;;AACAY,IAAAA,WAAW,CAACgC,cAAZ,CAA2BvB,IAA3B,CAAgC,IAAhC,EAAsCW,KAAtC,EAA6Ca,YAA7C;AACH,GAHD;;AAKAlC,EAAAA,MAAM,CAACmC,cAAP,GAAwB,UAAUd,KAAV,EAAiBa,YAAjB,EAA+B;AACnD9B,IAAAA,yBAAyB,GAAGiB,KAAK,CAAChC,QAAlC;;AACAY,IAAAA,WAAW,CAACkC,cAAZ,CAA2BzB,IAA3B,CAAgC,IAAhC,EAAsCW,KAAtC,EAA6Ca,YAA7C;AACH,GAHD;;AAKAlC,EAAAA,MAAM,CAACoC,eAAP,GAAyB,UAAUf,KAAV,EAAiB;AACtCjB,IAAAA,yBAAyB,GAAGiB,KAAK,CAAChC,QAAlC;;AACAY,IAAAA,WAAW,CAACmC,eAAZ,CAA4B1B,IAA5B,CAAiC,IAAjC,EAAuCW,KAAvC;;AAEA,QAAIgB,WAAW,GAAG,KAAKzD,WAAL,CAAiB0D,kBAAjB,CAAoC,KAAK3B,YAAL,CAAkBE,OAAtD,CAAlB;AAEAwB,IAAAA,WAAW,CAACvD,UAAZ,GAAyB,IAAzB;AACH,GAPD;;AASAkB,EAAAA,MAAM,CAACuC,sBAAP,GAAgC,YAAY;AACxCtC,IAAAA,WAAW,CAACsC,sBAAZ,CAAmC7B,IAAnC,CAAwC,IAAxC;;AACA,SAAKC,YAAL,CAAkBE,OAAlB,CAA0B/B,UAA1B,GAAuC,IAAvC;AACH,GAHD;;AAOAkB,EAAAA,MAAM,CAACwC,kBAAP,GAA4B,UAAUnB,KAAV,EAAiBoB,MAAjB,EAAyB;AACjDxC,IAAAA,WAAW,CAACuC,kBAAZ,CAA+B9B,IAA/B,CAAoC,IAApC,EAA0CW,KAA1C,EAAiDoB,MAAjD;;AAEA,QAAIC,QAAQ,GAAG,KAAK9D,WAAL,CAAiB+C,aAAjB,CAA+Bc,MAA/B,CAAf;AAAA,QACIE,WAAW,GAAGD,QAAQ,CAACA,QAAQ,CAACb,MAAT,GAAkB,CAAnB,CAD1B;AAGAc,IAAAA,WAAW,CAAC7D,UAAZ,GAAyBuC,KAAK,CAAChC,QAA/B;AACH,GAPD;;AAWAW,EAAAA,MAAM,CAAC4C,4BAAP,GAAsC,YAAY;AAG9CvC,IAAAA,2BAA2B,GAAGJ,WAAW,CAAC2C,4BAAZ,CAAyClC,IAAzC,CAA8C,IAA9C,CAA9B;AACA,WAAOL,2BAAP;AACH,GALD;;AAOAL,EAAAA,MAAM,CAAC6C,iBAAP,GAA2B,UAAUxB,KAAV,EAAiB;AACxCpB,IAAAA,WAAW,CAAC4C,iBAAZ,CAA8BnC,IAA9B,CAAmC,IAAnC,EAAyCW,KAAzC;;AAEA,QAAIyB,eAAe,GAAG,KAAKC,8BAAL,EAAtB;AAAA,QACIN,MAAM,GAAGK,eAAe,IAAIzC,2BAA2B,CAACoC,MAA/C,IACA,KAAK9B,YAAL,CAAkBqC,kBADlB,IAEA,KAAKrC,YAAL,CAAkBE,OAH/B;AAAA,QAIIoC,QAAQ,GAAG,KAAKrE,WAAL,CAAiB+C,aAAjB,CAA+Bc,MAA/B,CAJf;AAAA,QAKIS,WAAW,GAAGJ,eAAe,IAAIzC,2BAA2B,CAAC8C,aAA/C,GACdF,QAAQ,CAACG,OAAT,CAAiB/C,2BAA2B,CAAC8C,aAA7C,IAA8D,CADhD,GAEdF,QAAQ,CAACpB,MAAT,GAAkB,CAPtB;AAAA,QAQIwB,QAAQ,GAAGJ,QAAQ,CAACC,WAAD,CARvB;;AAWA,QAAIG,QAAQ,CAACvE,UAAb,EACIuE,QAAQ,CAACvE,UAAT,CAAoBK,SAApB,GAAgCkC,KAAK,CAAChC,QAAN,CAAeF,SAA/C,CADJ,KAIIkE,QAAQ,CAACvE,UAAT,GAAsBuC,KAAK,CAAChC,QAA5B;AACP,GAnBD;AAoBH,CA3JD","sourcesContent":["'use strict';\n\nvar OpenElementStack = require('../parser/open_element_stack'),\n    Tokenizer = require('../tokenizer'),\n    HTML = require('../common/html');\n\n\n//Aliases\nvar $ = HTML.TAG_NAMES;\n\n\nfunction setEndLocation(element, closingToken, treeAdapter) {\n    var loc = element.__location;\n\n    if (!loc)\n        return;\n\n    /**\n     * @typedef {Object} ElementLocationInfo\n     * @extends StartTagLocationInfo\n     *\n     * @property {StartTagLocationInfo} startTag - Element's start tag location info.\n     * @property {LocationInfo} endTag - Element's end tag location info.\n     */\n    if (!loc.startTag) {\n        loc.startTag = {\n            line: loc.line,\n            col: loc.col,\n            startOffset: loc.startOffset,\n            endOffset: loc.endOffset\n        };\n        if (loc.attrs)\n            loc.startTag.attrs = loc.attrs;\n    }\n\n    if (closingToken.location) {\n        var ctLocation = closingToken.location,\n            tn = treeAdapter.getTagName(element),\n        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing tag and\n        // for cases like <td> <p> </td> - 'p' closes without a closing tag\n            isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN &&\n                              tn === closingToken.tagName;\n\n        if (isClosingEndTag) {\n            loc.endTag = {\n                line: ctLocation.line,\n                col: ctLocation.col,\n                startOffset: ctLocation.startOffset,\n                endOffset: ctLocation.endOffset\n            };\n        }\n\n        if (isClosingEndTag)\n            loc.endOffset = ctLocation.endOffset;\n        else\n            loc.endOffset = ctLocation.startOffset;\n    }\n}\n\n\nexports.assign = function (parser) {\n    //NOTE: obtain Parser proto this way to avoid module circular references\n    var parserProto = Object.getPrototypeOf(parser),\n        treeAdapter = parser.treeAdapter,\n        attachableElementLocation = null,\n        lastFosterParentingLocation = null,\n        currentToken = null;\n\n\n    //NOTE: patch _bootstrap method\n    parser._bootstrap = function (document, fragmentContext) {\n        parserProto._bootstrap.call(this, document, fragmentContext);\n\n        attachableElementLocation = null;\n        lastFosterParentingLocation = null;\n        currentToken = null;\n\n        //OpenElementStack\n        parser.openElements.pop = function () {\n            setEndLocation(this.current, currentToken, treeAdapter);\n            OpenElementStack.prototype.pop.call(this);\n        };\n\n        parser.openElements.popAllUpToHtmlElement = function () {\n            for (var i = this.stackTop; i > 0; i--)\n                setEndLocation(this.items[i], currentToken, treeAdapter);\n\n            OpenElementStack.prototype.popAllUpToHtmlElement.call(this);\n        };\n\n        parser.openElements.remove = function (element) {\n            setEndLocation(element, currentToken, treeAdapter);\n            OpenElementStack.prototype.remove.call(this, element);\n        };\n    };\n\n\n    //Token processing\n    parser._processTokenInForeignContent = function (token) {\n        currentToken = token;\n        parserProto._processTokenInForeignContent.call(this, token);\n    };\n\n    parser._processToken = function (token) {\n        currentToken = token;\n        parserProto._processToken.call(this, token);\n\n        //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n        //their end location explicitly.\n        if (token.type === Tokenizer.END_TAG_TOKEN &&\n            (token.tagName === $.HTML ||\n             token.tagName === $.BODY && this.openElements.hasInScope($.BODY))) {\n            for (var i = this.openElements.stackTop; i >= 0; i--) {\n                var element = this.openElements.items[i];\n\n                if (this.treeAdapter.getTagName(element) === token.tagName) {\n                    setEndLocation(element, token, treeAdapter);\n                    break;\n                }\n            }\n        }\n    };\n\n\n    //Doctype\n    parser._setDocumentType = function (token) {\n        parserProto._setDocumentType.call(this, token);\n\n        var documentChildren = this.treeAdapter.getChildNodes(this.document),\n            cnLength = documentChildren.length;\n\n        for (var i = 0; i < cnLength; i++) {\n            var node = documentChildren[i];\n\n            if (this.treeAdapter.isDocumentTypeNode(node)) {\n                node.__location = token.location;\n                break;\n            }\n        }\n    };\n\n\n    //Elements\n    parser._attachElementToTree = function (element) {\n        //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n        //So we will use token location stored in this methods for the element.\n        element.__location = attachableElementLocation || null;\n        attachableElementLocation = null;\n        parserProto._attachElementToTree.call(this, element);\n    };\n\n    parser._appendElement = function (token, namespaceURI) {\n        attachableElementLocation = token.location;\n        parserProto._appendElement.call(this, token, namespaceURI);\n    };\n\n    parser._insertElement = function (token, namespaceURI) {\n        attachableElementLocation = token.location;\n        parserProto._insertElement.call(this, token, namespaceURI);\n    };\n\n    parser._insertTemplate = function (token) {\n        attachableElementLocation = token.location;\n        parserProto._insertTemplate.call(this, token);\n\n        var tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n\n        tmplContent.__location = null;\n    };\n\n    parser._insertFakeRootElement = function () {\n        parserProto._insertFakeRootElement.call(this);\n        this.openElements.current.__location = null;\n    };\n\n\n    //Comments\n    parser._appendCommentNode = function (token, parent) {\n        parserProto._appendCommentNode.call(this, token, parent);\n\n        var children = this.treeAdapter.getChildNodes(parent),\n            commentNode = children[children.length - 1];\n\n        commentNode.__location = token.location;\n    };\n\n\n    //Text\n    parser._findFosterParentingLocation = function () {\n        //NOTE: store last foster parenting location, so we will be able to find inserted text\n        //in case of foster parenting\n        lastFosterParentingLocation = parserProto._findFosterParentingLocation.call(this);\n        return lastFosterParentingLocation;\n    };\n\n    parser._insertCharacters = function (token) {\n        parserProto._insertCharacters.call(this, token);\n\n        var hasFosterParent = this._shouldFosterParentOnInsertion(),\n            parent = hasFosterParent && lastFosterParentingLocation.parent ||\n                     this.openElements.currentTmplContent ||\n                     this.openElements.current,\n            siblings = this.treeAdapter.getChildNodes(parent),\n            textNodeIdx = hasFosterParent && lastFosterParentingLocation.beforeElement ?\n            siblings.indexOf(lastFosterParentingLocation.beforeElement) - 1 :\n            siblings.length - 1,\n            textNode = siblings[textNodeIdx];\n\n        //NOTE: if we have location assigned by another token, then just update end position\n        if (textNode.__location)\n            textNode.__location.endOffset = token.location.endOffset;\n\n        else\n            textNode.__location = token.location;\n    };\n};\n\n"]},"metadata":{},"sourceType":"script"}