{"ast":null,"code":"'use strict';\n\nexports.Transform = Transform;\n\nvar Duplex = require(\"./_stream_duplex\").Duplex;\n\nvar util = require(\"./util\");\n\nutil.inherits(Transform, Duplex);\n\nfunction TransformState(stream) {\n  this.afterTransform = function (er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data !== null && data !== undefined) stream.push(data);\n  cb(er);\n  var rs = stream._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = new TransformState(this);\n  var stream = this;\n  this._readableState.needReadable = true;\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  this.once('prefinish', function () {\n    if (typeof this._flush === 'function') this._flush(function (er, data) {\n      done(stream, er, data);\n    });else done(stream);\n  });\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    ts.needTransform = true;\n  }\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data !== null && data !== undefined) stream.push(data);\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n  if (ws.length) throw new Error('Calling transform done when ws.length != 0');\n  if (ts.transforming) throw new Error('Calling transform done when still transforming');\n  return stream.push(null);\n}","map":{"version":3,"sources":["/Users/adarsh/Documents/StocksUI/node_modules/react-native-stream/src/_stream_transform.js"],"names":["exports","Transform","Duplex","require","util","inherits","TransformState","stream","afterTransform","er","data","needTransform","transforming","writecb","writechunk","writeencoding","ts","_transformState","cb","emit","Error","undefined","push","rs","_readableState","reading","needReadable","length","highWaterMark","_read","options","call","sync","transform","_transform","flush","_flush","once","done","prototype","chunk","encoding","_write","n","ws","_writableState"],"mappings":"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","sourcesContent":["// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nexports.Transform = Transform;\n\nconst Duplex = require('./_stream_duplex').Duplex;\nconst util = require('./util');\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function')\n      this._transform = options.transform;\n\n    if (typeof options.flush === 'function')\n      this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.once('prefinish', function() {\n    if (typeof this._flush === 'function')\n      this._flush(function(er, data) {\n        done(stream, er, data);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er, data) {\n  if (er)\n    return stream.emit('error', er);\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('Calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n"]},"metadata":{},"sourceType":"script"}