{"ast":null,"code":"'use strict';\n\nvar WritableStream = require('react-native-stream').Writable,\n    setPrototypeOf = require(\"../common/setPrototypeOf\"),\n    Parser = require(\"./index\");\n\nvar ParserStream = module.exports = function (options) {\n  WritableStream.call(this);\n  this.parser = new Parser(options);\n  this.lastChunkWritten = false;\n  this.writeCallback = null;\n  this.pausedByScript = false;\n  this.document = this.parser.treeAdapter.createDocument();\n  this.pendingHtmlInsertions = [];\n  this._resume = this._resume.bind(this);\n  this._documentWrite = this._documentWrite.bind(this);\n  this._scriptHandler = this._scriptHandler.bind(this);\n\n  this.parser._bootstrap(this.document, null);\n};\n\nsetPrototypeOf(ParserStream.prototype, WritableStream.prototype);\n\nParserStream.prototype._write = function (chunk, encoding, callback) {\n  this.writeCallback = callback;\n  this.parser.tokenizer.write(chunk.toString('utf8'), this.lastChunkWritten);\n\n  this._runParsingLoop();\n};\n\nParserStream.prototype.end = function (chunk, encoding, callback) {\n  this.lastChunkWritten = true;\n  WritableStream.prototype.end.call(this, chunk, encoding, callback);\n};\n\nParserStream.prototype._runParsingLoop = function () {\n  this.parser._runParsingLoop(this.writeCallback, this._scriptHandler);\n};\n\nParserStream.prototype._resume = function () {\n  if (!this.pausedByScript) throw new Error('Parser was already resumed');\n\n  while (this.pendingHtmlInsertions.length) {\n    var html = this.pendingHtmlInsertions.pop();\n    this.parser.tokenizer.insertHtmlAtCurrentPos(html);\n  }\n\n  this.pausedByScript = false;\n  if (this.parser.tokenizer.active) this._runParsingLoop();\n};\n\nParserStream.prototype._documentWrite = function (html) {\n  if (!this.parser.stopped) this.pendingHtmlInsertions.push(html);\n};\n\nParserStream.prototype._scriptHandler = function (scriptElement) {\n  if (this.listeners('script').length) {\n    this.pausedByScript = true;\n    this.emit('script', scriptElement, this._documentWrite, this._resume);\n  } else this._runParsingLoop();\n};","map":{"version":3,"sources":["/Users/adarsh/Documents/StocksUI/node_modules/react-native-parse-html/lib/parser/parser_stream.js"],"names":["WritableStream","require","Writable","setPrototypeOf","Parser","ParserStream","module","exports","options","call","parser","lastChunkWritten","writeCallback","pausedByScript","document","treeAdapter","createDocument","pendingHtmlInsertions","_resume","bind","_documentWrite","_scriptHandler","_bootstrap","prototype","_write","chunk","encoding","callback","tokenizer","write","toString","_runParsingLoop","end","Error","length","html","pop","insertHtmlAtCurrentPos","active","stopped","push","scriptElement","listeners","emit"],"mappings":"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","sourcesContent":["'use strict';\n\nvar WritableStream = require('react-native-stream').Writable,\n    setPrototypeOf = require('../common/setPrototypeOf'),\n    Parser = require('./index');\n\n/**\n * Streaming HTML parser with scripting support.\n * A [writable stream]{@link https://nodejs.org/api/stream.html#stream_class_stream_writable}.\n * @class ParserStream\n * @memberof parse5\n * @instance\n * @extends stream.Writable\n * @param {ParserOptions} options - Parsing options.\n * @example\n * var parse5 = require('parse5');\n * var http = require('http');\n *\n * // Fetch the google.com content and obtain it's <body> node\n * http.get('http://google.com', function(res) {\n *  var parser = new parse5.ParserStream();\n *\n *  parser.on('finish', function() {\n *      var body = parser.document.childNodes[0].childNodes[1];\n *  });\n *\n *  res.pipe(parser);\n * });\n */\nvar ParserStream = module.exports = function (options) {\n    WritableStream.call(this);\n\n    this.parser = new Parser(options);\n\n    this.lastChunkWritten = false;\n    this.writeCallback = null;\n    this.pausedByScript = false;\n\n    /**\n     * The resulting document node.\n     * @member {ASTNode<document>} document\n     * @memberof parse5#ParserStream\n     * @instance\n     */\n    this.document = this.parser.treeAdapter.createDocument();\n\n    this.pendingHtmlInsertions = [];\n\n    this._resume = this._resume.bind(this);\n    this._documentWrite = this._documentWrite.bind(this);\n    this._scriptHandler = this._scriptHandler.bind(this);\n\n    this.parser._bootstrap(this.document, null);\n};\n\nsetPrototypeOf(ParserStream.prototype, WritableStream.prototype);\n\n//WritableStream implementation\nParserStream.prototype._write = function (chunk, encoding, callback) {\n    this.writeCallback = callback;\n    this.parser.tokenizer.write(chunk.toString('utf8'), this.lastChunkWritten);\n    this._runParsingLoop();\n};\n\nParserStream.prototype.end = function (chunk, encoding, callback) {\n    this.lastChunkWritten = true;\n    WritableStream.prototype.end.call(this, chunk, encoding, callback);\n};\n\n//Scriptable parser implementation\nParserStream.prototype._runParsingLoop = function () {\n    this.parser._runParsingLoop(this.writeCallback, this._scriptHandler);\n};\n\nParserStream.prototype._resume = function () {\n    if (!this.pausedByScript)\n        throw new Error('Parser was already resumed');\n\n    while (this.pendingHtmlInsertions.length) {\n        var html = this.pendingHtmlInsertions.pop();\n\n        this.parser.tokenizer.insertHtmlAtCurrentPos(html);\n    }\n\n    this.pausedByScript = false;\n\n    //NOTE: keep parsing if we don't wait for the next input chunk\n    if (this.parser.tokenizer.active)\n        this._runParsingLoop();\n};\n\nParserStream.prototype._documentWrite = function (html) {\n    if (!this.parser.stopped)\n        this.pendingHtmlInsertions.push(html);\n};\n\nParserStream.prototype._scriptHandler = function (scriptElement) {\n    if (this.listeners('script').length) {\n        this.pausedByScript = true;\n\n        /**\n         * Raised then parser encounters a `<script>` element.\n         * If this event has listeners, parsing will be suspended once it is emitted.\n         * So, if `<script>` has the `src` attribute, you can fetch it, execute and then resume parsing just like browsers do.\n         * @event script\n         * @memberof parse5#ParserStream\n         * @instance\n         * @type {Function}\n         * @param {ASTNode} scriptElement - The script element that caused the event.\n         * @param {Function} documentWrite(html) - Write additional `html` at the current parsing position.\n         *  Suitable for implementing the DOM `document.write` and `document.writeln` methods.\n         * @param {Function} resume - Resumes parsing.\n         * @example\n         * var parse = require('parse5');\n         * var http = require('http');\n         *\n         * var parser = new parse5.ParserStream();\n         *\n         * parser.on('script', function(scriptElement, documentWrite, resume) {\n         *   var src = parse5.treeAdapters.default.getAttrList(scriptElement)[0].value;\n         *\n         *   http.get(src, function(res) {\n         *      // Fetch the script content, execute it with DOM built around `parser.document` and\n         *      // `document.write` implemented using `documentWrite`.\n         *      ...\n         *      // Then resume parsing.\n         *      resume();\n         *   });\n         * });\n         *\n         * parser.end('<script src=\"example.com/script.js\"></script>');\n         */\n\n\n        this.emit('script', scriptElement, this._documentWrite, this._resume);\n    }\n    else\n        this._runParsingLoop();\n};\n"]},"metadata":{},"sourceType":"script"}