{"ast":null,"code":"'use strict';\n\nvar UNICODE = require(\"../common/unicode\");\n\nvar $ = UNICODE.CODE_POINTS;\n\nexports.assign = function (tokenizer) {\n  var tokenizerProto = Object.getPrototypeOf(tokenizer),\n      tokenStartOffset = -1,\n      tokenCol = -1,\n      tokenLine = 1,\n      isEol = false,\n      lineStartPosStack = [0],\n      lineStartPos = 0,\n      col = -1,\n      line = 1;\n\n  function attachLocationInfo(token) {\n    token.location = {\n      line: tokenLine,\n      col: tokenCol,\n      startOffset: tokenStartOffset,\n      endOffset: -1\n    };\n  }\n\n  tokenizer._consume = function () {\n    var cp = tokenizerProto._consume.call(this);\n\n    if (isEol) {\n      isEol = false;\n      line++;\n      lineStartPosStack.push(this.preprocessor.sourcePos);\n      lineStartPos = this.preprocessor.sourcePos;\n    }\n\n    if (cp === $.LINE_FEED) isEol = true;\n    col = this.preprocessor.sourcePos - lineStartPos + 1;\n    return cp;\n  };\n\n  tokenizer._unconsume = function () {\n    tokenizerProto._unconsume.call(this);\n\n    isEol = false;\n\n    while (lineStartPos > this.preprocessor.sourcePos && lineStartPosStack.length > 1) {\n      lineStartPos = lineStartPosStack.pop();\n      line--;\n    }\n\n    col = this.preprocessor.sourcePos - lineStartPos + 1;\n  };\n\n  tokenizer._createStartTagToken = function () {\n    tokenizerProto._createStartTagToken.call(this);\n\n    attachLocationInfo(this.currentToken);\n  };\n\n  tokenizer._createEndTagToken = function () {\n    tokenizerProto._createEndTagToken.call(this);\n\n    attachLocationInfo(this.currentToken);\n  };\n\n  tokenizer._createCommentToken = function () {\n    tokenizerProto._createCommentToken.call(this);\n\n    attachLocationInfo(this.currentToken);\n  };\n\n  tokenizer._createDoctypeToken = function (initialName) {\n    tokenizerProto._createDoctypeToken.call(this, initialName);\n\n    attachLocationInfo(this.currentToken);\n  };\n\n  tokenizer._createCharacterToken = function (type, ch) {\n    tokenizerProto._createCharacterToken.call(this, type, ch);\n\n    attachLocationInfo(this.currentCharacterToken);\n  };\n\n  tokenizer._createAttr = function (attrNameFirstCh) {\n    tokenizerProto._createAttr.call(this, attrNameFirstCh);\n\n    this.currentAttrLocation = {\n      line: line,\n      col: col,\n      startOffset: this.preprocessor.sourcePos,\n      endOffset: -1\n    };\n  };\n\n  tokenizer._leaveAttrName = function (toState) {\n    tokenizerProto._leaveAttrName.call(this, toState);\n\n    this._attachCurrentAttrLocationInfo();\n  };\n\n  tokenizer._leaveAttrValue = function (toState) {\n    tokenizerProto._leaveAttrValue.call(this, toState);\n\n    this._attachCurrentAttrLocationInfo();\n  };\n\n  tokenizer._attachCurrentAttrLocationInfo = function () {\n    this.currentAttrLocation.endOffset = this.preprocessor.sourcePos;\n    if (!this.currentToken.location.attrs) this.currentToken.location.attrs = Object.create(null);\n    this.currentToken.location.attrs[this.currentAttr.name] = this.currentAttrLocation;\n  };\n\n  tokenizer._emitCurrentToken = function () {\n    if (this.currentCharacterToken) this.currentCharacterToken.location.endOffset = this.currentToken.location.startOffset;\n    this.currentToken.location.endOffset = this.preprocessor.sourcePos + 1;\n\n    tokenizerProto._emitCurrentToken.call(this);\n  };\n\n  tokenizer._emitCurrentCharacterToken = function () {\n    if (this.currentCharacterToken && this.currentCharacterToken.location.endOffset === -1) this.currentCharacterToken.location.endOffset = this.preprocessor.sourcePos;\n\n    tokenizerProto._emitCurrentCharacterToken.call(this);\n  };\n\n  Object.keys(tokenizerProto.MODE).map(function (modeName) {\n    return tokenizerProto.MODE[modeName];\n  }).forEach(function (state) {\n    tokenizer[state] = function (cp) {\n      tokenStartOffset = this.preprocessor.sourcePos;\n      tokenLine = line;\n      tokenCol = col;\n      tokenizerProto[state].call(this, cp);\n    };\n  });\n};","map":{"version":3,"sources":["/Users/adarsh/Documents/StocksUI/node_modules/react-native-parse-html/lib/location_info/tokenizer_mixin.js"],"names":["UNICODE","require","$","CODE_POINTS","exports","assign","tokenizer","tokenizerProto","Object","getPrototypeOf","tokenStartOffset","tokenCol","tokenLine","isEol","lineStartPosStack","lineStartPos","col","line","attachLocationInfo","token","location","startOffset","endOffset","_consume","cp","call","push","preprocessor","sourcePos","LINE_FEED","_unconsume","length","pop","_createStartTagToken","currentToken","_createEndTagToken","_createCommentToken","_createDoctypeToken","initialName","_createCharacterToken","type","ch","currentCharacterToken","_createAttr","attrNameFirstCh","currentAttrLocation","_leaveAttrName","toState","_attachCurrentAttrLocationInfo","_leaveAttrValue","attrs","create","currentAttr","name","_emitCurrentToken","_emitCurrentCharacterToken","keys","MODE","map","modeName","forEach","state"],"mappings":"AAAA;;AAEA,IAAIA,OAAO,GAAGC,OAAO,qBAArB;;AAGA,IAAIC,CAAC,GAAGF,OAAO,CAACG,WAAhB;;AAGAC,OAAO,CAACC,MAAR,GAAiB,UAAUC,SAAV,EAAqB;AAElC,MAAIC,cAAc,GAAGC,MAAM,CAACC,cAAP,CAAsBH,SAAtB,CAArB;AAAA,MACII,gBAAgB,GAAG,CAAC,CADxB;AAAA,MAEIC,QAAQ,GAAG,CAAC,CAFhB;AAAA,MAGIC,SAAS,GAAG,CAHhB;AAAA,MAIIC,KAAK,GAAG,KAJZ;AAAA,MAKIC,iBAAiB,GAAG,CAAC,CAAD,CALxB;AAAA,MAMIC,YAAY,GAAG,CANnB;AAAA,MAOIC,GAAG,GAAG,CAAC,CAPX;AAAA,MAQIC,IAAI,GAAG,CARX;;AAUA,WAASC,kBAAT,CAA4BC,KAA5B,EAAmC;AAS/BA,IAAAA,KAAK,CAACC,QAAN,GAAiB;AACbH,MAAAA,IAAI,EAAEL,SADO;AAEbI,MAAAA,GAAG,EAAEL,QAFQ;AAGbU,MAAAA,WAAW,EAAEX,gBAHA;AAIbY,MAAAA,SAAS,EAAE,CAAC;AAJC,KAAjB;AAMH;;AAGDhB,EAAAA,SAAS,CAACiB,QAAV,GAAqB,YAAY;AAC7B,QAAIC,EAAE,GAAGjB,cAAc,CAACgB,QAAf,CAAwBE,IAAxB,CAA6B,IAA7B,CAAT;;AAGA,QAAIZ,KAAJ,EAAW;AACPA,MAAAA,KAAK,GAAG,KAAR;AACAI,MAAAA,IAAI;AACJH,MAAAA,iBAAiB,CAACY,IAAlB,CAAuB,KAAKC,YAAL,CAAkBC,SAAzC;AACAb,MAAAA,YAAY,GAAG,KAAKY,YAAL,CAAkBC,SAAjC;AACH;;AAED,QAAIJ,EAAE,KAAKtB,CAAC,CAAC2B,SAAb,EACIhB,KAAK,GAAG,IAAR;AAEJG,IAAAA,GAAG,GAAG,KAAKW,YAAL,CAAkBC,SAAlB,GAA8Bb,YAA9B,GAA6C,CAAnD;AAEA,WAAOS,EAAP;AACH,GAjBD;;AAmBAlB,EAAAA,SAAS,CAACwB,UAAV,GAAuB,YAAY;AAC/BvB,IAAAA,cAAc,CAACuB,UAAf,CAA0BL,IAA1B,CAA+B,IAA/B;;AACAZ,IAAAA,KAAK,GAAG,KAAR;;AAEA,WAAOE,YAAY,GAAG,KAAKY,YAAL,CAAkBC,SAAjC,IAA8Cd,iBAAiB,CAACiB,MAAlB,GAA2B,CAAhF,EAAmF;AAC/EhB,MAAAA,YAAY,GAAGD,iBAAiB,CAACkB,GAAlB,EAAf;AACAf,MAAAA,IAAI;AACP;;AAEDD,IAAAA,GAAG,GAAG,KAAKW,YAAL,CAAkBC,SAAlB,GAA8Bb,YAA9B,GAA6C,CAAnD;AACH,GAVD;;AAaAT,EAAAA,SAAS,CAAC2B,oBAAV,GAAiC,YAAY;AACzC1B,IAAAA,cAAc,CAAC0B,oBAAf,CAAoCR,IAApC,CAAyC,IAAzC;;AACAP,IAAAA,kBAAkB,CAAC,KAAKgB,YAAN,CAAlB;AACH,GAHD;;AAKA5B,EAAAA,SAAS,CAAC6B,kBAAV,GAA+B,YAAY;AACvC5B,IAAAA,cAAc,CAAC4B,kBAAf,CAAkCV,IAAlC,CAAuC,IAAvC;;AACAP,IAAAA,kBAAkB,CAAC,KAAKgB,YAAN,CAAlB;AACH,GAHD;;AAKA5B,EAAAA,SAAS,CAAC8B,mBAAV,GAAgC,YAAY;AACxC7B,IAAAA,cAAc,CAAC6B,mBAAf,CAAmCX,IAAnC,CAAwC,IAAxC;;AACAP,IAAAA,kBAAkB,CAAC,KAAKgB,YAAN,CAAlB;AACH,GAHD;;AAKA5B,EAAAA,SAAS,CAAC+B,mBAAV,GAAgC,UAAUC,WAAV,EAAuB;AACnD/B,IAAAA,cAAc,CAAC8B,mBAAf,CAAmCZ,IAAnC,CAAwC,IAAxC,EAA8Ca,WAA9C;;AACApB,IAAAA,kBAAkB,CAAC,KAAKgB,YAAN,CAAlB;AACH,GAHD;;AAKA5B,EAAAA,SAAS,CAACiC,qBAAV,GAAkC,UAAUC,IAAV,EAAgBC,EAAhB,EAAoB;AAClDlC,IAAAA,cAAc,CAACgC,qBAAf,CAAqCd,IAArC,CAA0C,IAA1C,EAAgDe,IAAhD,EAAsDC,EAAtD;;AACAvB,IAAAA,kBAAkB,CAAC,KAAKwB,qBAAN,CAAlB;AACH,GAHD;;AAKApC,EAAAA,SAAS,CAACqC,WAAV,GAAwB,UAAUC,eAAV,EAA2B;AAC/CrC,IAAAA,cAAc,CAACoC,WAAf,CAA2BlB,IAA3B,CAAgC,IAAhC,EAAsCmB,eAAtC;;AACA,SAAKC,mBAAL,GAA2B;AACvB5B,MAAAA,IAAI,EAAEA,IADiB;AAEvBD,MAAAA,GAAG,EAAEA,GAFkB;AAGvBK,MAAAA,WAAW,EAAE,KAAKM,YAAL,CAAkBC,SAHR;AAIvBN,MAAAA,SAAS,EAAE,CAAC;AAJW,KAA3B;AAMH,GARD;;AAUAhB,EAAAA,SAAS,CAACwC,cAAV,GAA2B,UAAUC,OAAV,EAAmB;AAC1CxC,IAAAA,cAAc,CAACuC,cAAf,CAA8BrB,IAA9B,CAAmC,IAAnC,EAAyCsB,OAAzC;;AACA,SAAKC,8BAAL;AACH,GAHD;;AAKA1C,EAAAA,SAAS,CAAC2C,eAAV,GAA4B,UAAUF,OAAV,EAAmB;AAC3CxC,IAAAA,cAAc,CAAC0C,eAAf,CAA+BxB,IAA/B,CAAoC,IAApC,EAA0CsB,OAA1C;;AACA,SAAKC,8BAAL;AACH,GAHD;;AAKA1C,EAAAA,SAAS,CAAC0C,8BAAV,GAA2C,YAAY;AACnD,SAAKH,mBAAL,CAAyBvB,SAAzB,GAAqC,KAAKK,YAAL,CAAkBC,SAAvD;AAEA,QAAI,CAAC,KAAKM,YAAL,CAAkBd,QAAlB,CAA2B8B,KAAhC,EACI,KAAKhB,YAAL,CAAkBd,QAAlB,CAA2B8B,KAA3B,GAAmC1C,MAAM,CAAC2C,MAAP,CAAc,IAAd,CAAnC;AAQJ,SAAKjB,YAAL,CAAkBd,QAAlB,CAA2B8B,KAA3B,CAAiC,KAAKE,WAAL,CAAiBC,IAAlD,IAA0D,KAAKR,mBAA/D;AACH,GAbD;;AAgBAvC,EAAAA,SAAS,CAACgD,iBAAV,GAA8B,YAAY;AAGtC,QAAI,KAAKZ,qBAAT,EACI,KAAKA,qBAAL,CAA2BtB,QAA3B,CAAoCE,SAApC,GAAgD,KAAKY,YAAL,CAAkBd,QAAlB,CAA2BC,WAA3E;AAEJ,SAAKa,YAAL,CAAkBd,QAAlB,CAA2BE,SAA3B,GAAuC,KAAKK,YAAL,CAAkBC,SAAlB,GAA8B,CAArE;;AACArB,IAAAA,cAAc,CAAC+C,iBAAf,CAAiC7B,IAAjC,CAAsC,IAAtC;AACH,GARD;;AAUAnB,EAAAA,SAAS,CAACiD,0BAAV,GAAuC,YAAY;AAM/C,QAAI,KAAKb,qBAAL,IAA8B,KAAKA,qBAAL,CAA2BtB,QAA3B,CAAoCE,SAApC,KAAkD,CAAC,CAArF,EACI,KAAKoB,qBAAL,CAA2BtB,QAA3B,CAAoCE,SAApC,GAAgD,KAAKK,YAAL,CAAkBC,SAAlE;;AAEJrB,IAAAA,cAAc,CAACgD,0BAAf,CAA0C9B,IAA1C,CAA+C,IAA/C;AACH,GAVD;;AAaAjB,EAAAA,MAAM,CAACgD,IAAP,CAAYjD,cAAc,CAACkD,IAA3B,EAEKC,GAFL,CAES,UAAUC,QAAV,EAAoB;AACrB,WAAOpD,cAAc,CAACkD,IAAf,CAAoBE,QAApB,CAAP;AACH,GAJL,EAMKC,OANL,CAMa,UAAUC,KAAV,EAAiB;AACtBvD,IAAAA,SAAS,CAACuD,KAAD,CAAT,GAAmB,UAAUrC,EAAV,EAAc;AAC7Bd,MAAAA,gBAAgB,GAAG,KAAKiB,YAAL,CAAkBC,SAArC;AACAhB,MAAAA,SAAS,GAAGK,IAAZ;AACAN,MAAAA,QAAQ,GAAGK,GAAX;AACAT,MAAAA,cAAc,CAACsD,KAAD,CAAd,CAAsBpC,IAAtB,CAA2B,IAA3B,EAAiCD,EAAjC;AACH,KALD;AAMH,GAbL;AAcH,CAhKD","sourcesContent":["'use strict';\n\nvar UNICODE = require('../common/unicode');\n\n//Aliases\nvar $ = UNICODE.CODE_POINTS;\n\n\nexports.assign = function (tokenizer) {\n    //NOTE: obtain Tokenizer proto this way to avoid module circular references\n    var tokenizerProto = Object.getPrototypeOf(tokenizer),\n        tokenStartOffset = -1,\n        tokenCol = -1,\n        tokenLine = 1,\n        isEol = false,\n        lineStartPosStack = [0],\n        lineStartPos = 0,\n        col = -1,\n        line = 1;\n\n    function attachLocationInfo(token) {\n        /**\n         * @typedef {Object} LocationInfo\n         *\n         * @property {Number} line - One-based line index\n         * @property {Number} col - One-based column index\n         * @property {Number} startOffset - Zero-based first character index\n         * @property {Number} endOffset - Zero-based last character index\n         */\n        token.location = {\n            line: tokenLine,\n            col: tokenCol,\n            startOffset: tokenStartOffset,\n            endOffset: -1\n        };\n    }\n\n    //NOTE: patch consumption method to track line/col information\n    tokenizer._consume = function () {\n        var cp = tokenizerProto._consume.call(this);\n\n        //NOTE: LF should be in the last column of the line\n        if (isEol) {\n            isEol = false;\n            line++;\n            lineStartPosStack.push(this.preprocessor.sourcePos);\n            lineStartPos = this.preprocessor.sourcePos;\n        }\n\n        if (cp === $.LINE_FEED)\n            isEol = true;\n\n        col = this.preprocessor.sourcePos - lineStartPos + 1;\n\n        return cp;\n    };\n\n    tokenizer._unconsume = function () {\n        tokenizerProto._unconsume.call(this);\n        isEol = false;\n\n        while (lineStartPos > this.preprocessor.sourcePos && lineStartPosStack.length > 1) {\n            lineStartPos = lineStartPosStack.pop();\n            line--;\n        }\n\n        col = this.preprocessor.sourcePos - lineStartPos + 1;\n    };\n\n    //NOTE: patch token creation methods and attach location objects\n    tokenizer._createStartTagToken = function () {\n        tokenizerProto._createStartTagToken.call(this);\n        attachLocationInfo(this.currentToken);\n    };\n\n    tokenizer._createEndTagToken = function () {\n        tokenizerProto._createEndTagToken.call(this);\n        attachLocationInfo(this.currentToken);\n    };\n\n    tokenizer._createCommentToken = function () {\n        tokenizerProto._createCommentToken.call(this);\n        attachLocationInfo(this.currentToken);\n    };\n\n    tokenizer._createDoctypeToken = function (initialName) {\n        tokenizerProto._createDoctypeToken.call(this, initialName);\n        attachLocationInfo(this.currentToken);\n    };\n\n    tokenizer._createCharacterToken = function (type, ch) {\n        tokenizerProto._createCharacterToken.call(this, type, ch);\n        attachLocationInfo(this.currentCharacterToken);\n    };\n\n    tokenizer._createAttr = function (attrNameFirstCh) {\n        tokenizerProto._createAttr.call(this, attrNameFirstCh);\n        this.currentAttrLocation = {\n            line: line,\n            col: col,\n            startOffset: this.preprocessor.sourcePos,\n            endOffset: -1\n        };\n    };\n\n    tokenizer._leaveAttrName = function (toState) {\n        tokenizerProto._leaveAttrName.call(this, toState);\n        this._attachCurrentAttrLocationInfo();\n    };\n\n    tokenizer._leaveAttrValue = function (toState) {\n        tokenizerProto._leaveAttrValue.call(this, toState);\n        this._attachCurrentAttrLocationInfo();\n    };\n\n    tokenizer._attachCurrentAttrLocationInfo = function () {\n        this.currentAttrLocation.endOffset = this.preprocessor.sourcePos;\n\n        if (!this.currentToken.location.attrs)\n            this.currentToken.location.attrs = Object.create(null);\n\n        /**\n         * @typedef {Object} StartTagLocationInfo\n         * @extends LocationInfo\n         *\n         * @property {Dictionary<String, LocationInfo>} attrs - Start tag attributes' location info.\n         */\n        this.currentToken.location.attrs[this.currentAttr.name] = this.currentAttrLocation;\n    };\n\n    //NOTE: patch token emission methods to determine end location\n    tokenizer._emitCurrentToken = function () {\n        //NOTE: if we have pending character token make it's end location equal to the\n        //current token's start location.\n        if (this.currentCharacterToken)\n            this.currentCharacterToken.location.endOffset = this.currentToken.location.startOffset;\n\n        this.currentToken.location.endOffset = this.preprocessor.sourcePos + 1;\n        tokenizerProto._emitCurrentToken.call(this);\n    };\n\n    tokenizer._emitCurrentCharacterToken = function () {\n        //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),\n        //then set it's location at the current preprocessor position.\n        //We don't need to increment preprocessor position, since character token\n        //emission is always forced by the start of the next character token here.\n        //So, we already have advanced position.\n        if (this.currentCharacterToken && this.currentCharacterToken.location.endOffset === -1)\n            this.currentCharacterToken.location.endOffset = this.preprocessor.sourcePos;\n\n        tokenizerProto._emitCurrentCharacterToken.call(this);\n    };\n\n    //NOTE: patch initial states for each mode to obtain token start position\n    Object.keys(tokenizerProto.MODE)\n\n        .map(function (modeName) {\n            return tokenizerProto.MODE[modeName];\n        })\n\n        .forEach(function (state) {\n            tokenizer[state] = function (cp) {\n                tokenStartOffset = this.preprocessor.sourcePos;\n                tokenLine = line;\n                tokenCol = col;\n                tokenizerProto[state].call(this, cp);\n            };\n        });\n};\n"]},"metadata":{},"sourceType":"script"}