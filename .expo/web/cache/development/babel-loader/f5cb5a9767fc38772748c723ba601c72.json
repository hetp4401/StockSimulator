{"ast":null,"code":"'use strict';\n\nvar TransformStream = require('react-native-stream').Transform,\n    setPrototypeOf = require(\"../common/setPrototypeOf\"),\n    DevNullStream = require(\"./dev_null_stream\"),\n    Tokenizer = require(\"../tokenizer\"),\n    ParserFeedbackSimulator = require(\"./parser_feedback_simulator\"),\n    mergeOptions = require(\"../common/merge_options\");\n\nvar DEFAULT_OPTIONS = {\n  locationInfo: false\n};\n\nvar SAXParser = module.exports = function (options) {\n  TransformStream.call(this);\n  this.options = mergeOptions(DEFAULT_OPTIONS, options);\n  this.tokenizer = new Tokenizer(options);\n  this.parserFeedbackSimulator = new ParserFeedbackSimulator(this.tokenizer);\n  this.pendingText = null;\n  this.currentTokenLocation = void 0;\n  this.lastChunkWritten = false;\n  this.stopped = false;\n  this.pipe(new DevNullStream());\n};\n\nsetPrototypeOf(SAXParser.prototype, TransformStream.prototype);\n\nSAXParser.prototype._transform = function (chunk, encoding, callback) {\n  if (!this.stopped) {\n    this.tokenizer.write(chunk.toString('utf8'), this.lastChunkWritten);\n\n    this._runParsingLoop();\n  }\n\n  this.push(chunk);\n  callback();\n};\n\nSAXParser.prototype._flush = function (callback) {\n  callback();\n};\n\nSAXParser.prototype.end = function (chunk, encoding, callback) {\n  this.lastChunkWritten = true;\n  TransformStream.prototype.end.call(this, chunk, encoding, callback);\n};\n\nSAXParser.prototype.stop = function () {\n  this.stopped = true;\n};\n\nSAXParser.prototype._runParsingLoop = function () {\n  do {\n    var token = this.parserFeedbackSimulator.getNextToken();\n    if (token.type === Tokenizer.HIBERNATION_TOKEN) break;\n\n    if (token.type === Tokenizer.CHARACTER_TOKEN || token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN || token.type === Tokenizer.NULL_CHARACTER_TOKEN) {\n      if (this.options.locationInfo) {\n        if (this.pendingText === null) this.currentTokenLocation = token.location;else this.currentTokenLocation.endOffset = token.location.endOffset;\n      }\n\n      this.pendingText = (this.pendingText || '') + token.chars;\n    } else {\n      this._emitPendingText();\n\n      this._handleToken(token);\n    }\n  } while (!this.stopped && token.type !== Tokenizer.EOF_TOKEN);\n};\n\nSAXParser.prototype._handleToken = function (token) {\n  if (this.options.locationInfo) this.currentTokenLocation = token.location;\n  if (token.type === Tokenizer.START_TAG_TOKEN) this.emit('startTag', token.tagName, token.attrs, token.selfClosing, this.currentTokenLocation);else if (token.type === Tokenizer.END_TAG_TOKEN) this.emit('endTag', token.tagName, this.currentTokenLocation);else if (token.type === Tokenizer.COMMENT_TOKEN) this.emit('comment', token.data, this.currentTokenLocation);else if (token.type === Tokenizer.DOCTYPE_TOKEN) this.emit('doctype', token.name, token.publicId, token.systemId, this.currentTokenLocation);\n};\n\nSAXParser.prototype._emitPendingText = function () {\n  if (this.pendingText !== null) {\n    this.emit('text', this.pendingText, this.currentTokenLocation);\n    this.pendingText = null;\n  }\n};","map":{"version":3,"sources":["/Users/adarsh/Documents/StocksUI/node_modules/react-native-parse-html/lib/sax/index.js"],"names":["TransformStream","require","Transform","setPrototypeOf","DevNullStream","Tokenizer","ParserFeedbackSimulator","mergeOptions","DEFAULT_OPTIONS","locationInfo","SAXParser","module","exports","options","call","tokenizer","parserFeedbackSimulator","pendingText","currentTokenLocation","lastChunkWritten","stopped","pipe","prototype","_transform","chunk","encoding","callback","write","toString","_runParsingLoop","push","_flush","end","stop","token","getNextToken","type","HIBERNATION_TOKEN","CHARACTER_TOKEN","WHITESPACE_CHARACTER_TOKEN","NULL_CHARACTER_TOKEN","location","endOffset","chars","_emitPendingText","_handleToken","EOF_TOKEN","START_TAG_TOKEN","emit","tagName","attrs","selfClosing","END_TAG_TOKEN","COMMENT_TOKEN","data","DOCTYPE_TOKEN","name","publicId","systemId"],"mappings":"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","sourcesContent":["'use strict';\n\nvar TransformStream = require('react-native-stream').Transform,\n    setPrototypeOf = require('../common/setPrototypeOf'),\n    DevNullStream = require('./dev_null_stream'),\n    Tokenizer = require('../tokenizer'),\n    ParserFeedbackSimulator = require('./parser_feedback_simulator'),\n    mergeOptions = require('../common/merge_options');\n\n/**\n * @typedef {Object} SAXParserOptions\n *\n * @property {Boolean} [locationInfo=false] - Enables source code location information for the tokens.\n * When enabled, each token event handler will receive {@link LocationInfo} (or {@link StartTagLocationInfo})\n * object as its last argument.\n */\nvar DEFAULT_OPTIONS = {\n    locationInfo: false\n};\n\n/**\n * Streaming [SAX]{@link https://en.wikipedia.org/wiki/Simple_API_for_XML}-style HTML parser.\n * A [transform stream](https://nodejs.org/api/stream.html#stream_class_stream_transform)\n * (which means you can pipe *through* it, see example).\n * @class SAXParser\n * @memberof parse5\n * @instance\n * @extends stream.Transform\n * @param {SAXParserOptions} options - Parsing options.\n * @example\n * var parse5 = require('parse5');\n * var http = require('http');\n * var fs = require('fs');\n *\n * var file = fs.createWriteStream('/home/google.com.html');\n * var parser = new parse5.SAXParser();\n *\n * parser.on('text', function(text) {\n *  // Handle page text content\n *  ...\n * });\n *\n * http.get('http://google.com', function(res) {\n *  // SAXParser is the Transform stream, which means you can pipe\n *  // through it. So, you can analyze page content and, e.g., save it\n *  // to the file at the same time:\n *  res.pipe(parser).pipe(file);\n * });\n */\nvar SAXParser = module.exports = function (options) {\n    TransformStream.call(this);\n\n    this.options = mergeOptions(DEFAULT_OPTIONS, options);\n\n    this.tokenizer = new Tokenizer(options);\n    this.parserFeedbackSimulator = new ParserFeedbackSimulator(this.tokenizer);\n\n    this.pendingText = null;\n    this.currentTokenLocation = void 0;\n\n    this.lastChunkWritten = false;\n    this.stopped = false;\n\n    // NOTE: always pipe stream to the /dev/null stream to avoid\n    // `highWaterMark` hit even if we don't have consumers.\n    // (see: https://github.com/inikulin/parse5/issues/97#issuecomment-171940774)\n    this.pipe(new DevNullStream());\n};\n\nsetPrototypeOf(SAXParser.prototype, TransformStream.prototype);\n\n//TransformStream implementation\nSAXParser.prototype._transform = function (chunk, encoding, callback) {\n    if (!this.stopped) {\n        this.tokenizer.write(chunk.toString('utf8'), this.lastChunkWritten);\n        this._runParsingLoop();\n    }\n\n    this.push(chunk);\n\n    callback();\n};\n\nSAXParser.prototype._flush = function (callback) {\n    callback();\n};\n\nSAXParser.prototype.end = function (chunk, encoding, callback) {\n    this.lastChunkWritten = true;\n    TransformStream.prototype.end.call(this, chunk, encoding, callback);\n};\n\n/**\n * Stops parsing. Useful if you want the parser to stop consuming CPU time once you've obtained the desired info\n * from the input stream. Doesn't prevent piping, so that data will flow through the parser as usual.\n *\n * @function stop\n * @memberof parse5#SAXParser\n * @instance\n * @example\n * var parse5 = require('parse5');\n * var http = require('http');\n * var fs = require('fs');\n *\n * var file = fs.createWriteStream('/home/google.com.html');\n * var parser = new parse5.SAXParser();\n *\n * parser.on('doctype', function(name, publicId, systemId) {\n *  // Process doctype info ans stop parsing\n *  ...\n *  parser.stop();\n * });\n *\n * http.get('http://google.com', function(res) {\n *  // Despite the fact that parser.stop() was called whole\n *  // content of the page will be written to the file\n *  res.pipe(parser).pipe(file);\n * });\n */\nSAXParser.prototype.stop = function () {\n    this.stopped = true;\n};\n\n//Internals\nSAXParser.prototype._runParsingLoop = function () {\n    do {\n        var token = this.parserFeedbackSimulator.getNextToken();\n\n        if (token.type === Tokenizer.HIBERNATION_TOKEN)\n            break;\n\n        if (token.type === Tokenizer.CHARACTER_TOKEN ||\n            token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN ||\n            token.type === Tokenizer.NULL_CHARACTER_TOKEN) {\n\n            if (this.options.locationInfo) {\n                if (this.pendingText === null)\n                    this.currentTokenLocation = token.location;\n\n                else\n                    this.currentTokenLocation.endOffset = token.location.endOffset;\n            }\n\n            this.pendingText = (this.pendingText || '') + token.chars;\n        }\n\n        else {\n            this._emitPendingText();\n            this._handleToken(token);\n        }\n    } while (!this.stopped && token.type !== Tokenizer.EOF_TOKEN);\n};\n\nSAXParser.prototype._handleToken = function (token) {\n    if (this.options.locationInfo)\n        this.currentTokenLocation = token.location;\n\n    if (token.type === Tokenizer.START_TAG_TOKEN)\n        /**\n         * Raised when the parser encounters a start tag.\n         * @event startTag\n         * @memberof parse5#SAXParser\n         * @instance\n         * @type {Function}\n         * @param {String} name - Tag name.\n         * @param {Array} attrs - List of attributes in the `{ name: String, value: String, prefix?: String }` form.\n         * @param {Boolean} selfClosing - Indicates if the tag is self-closing.\n         * @param {StartTagLocationInfo} [location] - Start tag source code location info.\n         * Available if location info is enabled in {@link SAXParserOptions}.\n         */\n        this.emit('startTag', token.tagName, token.attrs, token.selfClosing, this.currentTokenLocation);\n\n    else if (token.type === Tokenizer.END_TAG_TOKEN)\n        /**\n         * Raised then parser encounters an end tag.\n         * @event endTag\n         * @memberof parse5#SAXParser\n         * @instance\n         * @type {Function}\n         * @param {String} name - Tag name.\n         * @param {LocationInfo} [location] - End tag source code location info.\n         * Available if location info is enabled in {@link SAXParserOptions}.\n         */\n        this.emit('endTag', token.tagName, this.currentTokenLocation);\n\n    else if (token.type === Tokenizer.COMMENT_TOKEN)\n        /**\n         * Raised then parser encounters a comment.\n         * @event comment\n         * @memberof parse5#SAXParser\n         * @instance\n         * @type {Function}\n         * @param {String} text - Comment text.\n         * @param {LocationInfo} [location] - Comment source code location info.\n         * Available if location info is enabled in {@link SAXParserOptions}.\n         */\n        this.emit('comment', token.data, this.currentTokenLocation);\n\n    else if (token.type === Tokenizer.DOCTYPE_TOKEN)\n        /**\n         * Raised then parser encounters a [document type declaration]{@link https://en.wikipedia.org/wiki/Document_type_declaration}.\n         * @event doctype\n         * @memberof parse5#SAXParser\n         * @instance\n         * @type {Function}\n         * @param {String} name - Document type name.\n         * @param {String} publicId - Document type public identifier.\n         * @param {String} systemId - Document type system identifier.\n         * @param {LocationInfo} [location] - Document type declaration source code location info.\n         * Available if location info is enabled in {@link SAXParserOptions}.\n         */\n        this.emit('doctype', token.name, token.publicId, token.systemId, this.currentTokenLocation);\n};\n\nSAXParser.prototype._emitPendingText = function () {\n    if (this.pendingText !== null) {\n        /**\n         * Raised then parser encounters text content.\n         * @event text\n         * @memberof parse5#SAXParser\n         * @instance\n         * @type {Function}\n         * @param {String} text - Text content.\n         * @param {LocationInfo} [location] - Text content code location info.\n         * Available if location info is enabled in {@link SAXParserOptions}.\n         */\n        this.emit('text', this.pendingText, this.currentTokenLocation);\n        this.pendingText = null;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}